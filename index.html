<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>æ©Ÿè»Šå›æ”¶èƒ½æºæ¨¡çµ„ 3D æ¨¡æ“¬</title>
    <style>
        /* --- åŸºç¤è¨­å®š --- */
        body { margin: 0; overflow: hidden; background-color: #f0f2f5; color: #333; font-family: 'Noto Sans TC', sans-serif; user-select: none; -webkit-tap-highlight-color: transparent; }
        
        /* é€šç”¨ UI éæ¸¡ */
        .ui-element { transition: opacity 0.3s ease, transform 0.3s ease, height 0.3s ease; }
        .ui-hidden { opacity: 0 !important; pointer-events: none !important; transform: translateY(-10px); }
        .panel-collapsed { height: 50px !important; overflow: hidden !important; padding-bottom: 0 !important; }

        /* è³‡è¨Šé¢æ¿ */
        #info {
            position: absolute; top: 20px; left: 20px; pointer-events: none;
            background: rgba(10, 15, 20, 0.85); padding: 20px;
            border-radius: 8px; border-left: 4px solid #00d2ff;
            backdrop-filter: blur(10px); box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            width: 300px;
            z-index: 10;
        }
        h1 { margin: 0; font-size: 1.4rem; color: #00d2ff; text-shadow: 0 0 10px rgba(0, 210, 255, 0.5); letter-spacing: 1px; }
        .status-badge { display: inline-block; background: rgba(0, 210, 255, 0.2); border: 1px solid #00d2ff; padding: 2px 8px; border-radius: 12px; font-size: 0.75rem; margin-top: 5px; }
        #guide-text { margin: 5px 0 0; font-size: 0.85rem; color: #ddd; opacity: 0.9; }

        /* åº•éƒ¨å°èˆªåˆ— */
        #bottom-nav {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 15px; z-index: 20;
            background: rgba(20, 25, 35, 0.9); padding: 10px 20px; border-radius: 30px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.1); backdrop-filter: blur(10px);
        }
        .nav-btn {
            background: transparent; border: none; color: #aaa; font-size: 0.8rem;
            display: flex; flex-direction: column; align-items: center; gap: 4px;
            cursor: pointer; transition: all 0.2s; min-width: 60px;
        }
        .nav-btn span { font-size: 1.4rem; }
        .nav-btn.active, .nav-btn:active { color: #00d2ff; transform: scale(1.1); }

        /* æŠ½å±œå¼æ§åˆ¶é¢æ¿ */
        #control-drawer {
            position: absolute; bottom: -100%; left: 0; width: 100%;
            background: rgba(15, 20, 30, 0.95); border-top-left-radius: 20px; border-top-right-radius: 20px;
            padding: 20px; box-sizing: border-box; transition: bottom 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 15; border-top: 1px solid #334; box-shadow: 0 -5px 30px rgba(0,0,0,0.5);
            max-height: 60vh; overflow-y: auto;
        }
        #control-drawer.open { bottom: 0; }
        .drawer-handle { width: 40px; height: 4px; background: #445; border-radius: 2px; margin: 0 auto 20px auto; }
        
        .control-group { margin-bottom: 15px; }
        .control-label { display: flex; justify-content: space-between; color: #ccc; font-size: 0.9rem; margin-bottom: 8px; }
        .highlight { color: #00d2ff; font-weight: bold; }

        input[type=range] { -webkit-appearance: none; width: 100%; background: transparent; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; height: 20px; width: 20px; border-radius: 50%; background: #00d2ff; cursor: pointer; margin-top: -8px; box-shadow: 0 0 10px rgba(0,210,255,0.5); border: 2px solid #fff; }
        input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 4px; cursor: pointer; background: #445; border-radius: 2px; }
        
        .mode-switch { display: flex; background: #0a0e15; border-radius: 8px; padding: 4px; }
        .mode-btn { flex: 1; border: none; background: transparent; color: #667; padding: 10px; font-size: 0.9rem; cursor: pointer; border-radius: 6px; transition: all 0.3s; font-weight: 600; }
        .mode-btn.active { background: rgba(0, 210, 255, 0.2); color: #00d2ff; }
        .mode-btn.active.drive { background: rgba(255, 170, 0, 0.2); color: #ffaa00; }

        /* å°è¦½æ°£æ³¡ */
        #tour-overlay {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0, 210, 255, 0.9); color: #000; padding: 15px 20px;
            border-radius: 12px; font-weight: bold; text-align: center; max-width: 80%;
            display: none; pointer-events: none; box-shadow: 0 0 20px rgba(0, 210, 255, 0.4); z-index: 30;
            animation: float 3s ease-in-out infinite;
        }
        #tour-overlay::after {
            content: ''; position: absolute; top: 100%; left: 50%; margin-left: -8px;
            border-width: 8px; border-style: solid; border-color: rgba(0, 210, 255, 0.9) transparent transparent transparent;
        }
        @keyframes float { 0%, 100% { transform: translate(-50%, -50%); } 50% { transform: translate(-50%, -60%); } }
        
        /* äº’å‹•æç¤ºæŒ‡ç´‹ */
        #interaction-hint {
            position: absolute; width: 40px; height: 40px; border: 2px solid #00d2ff; border-radius: 50%;
            top: 50%; left: 50%; display: none; pointer-events: none; animation: ripple 1.5s infinite; z-index: 25;
        }
        @keyframes ripple { 0% { transform: scale(0.5); opacity: 1; } 100% { transform: scale(1.5); opacity: 0; } }

        #tooltip { position: absolute; display: none; background: rgba(0, 210, 255, 0.9); color: #000; padding: 6px 12px; border-radius: 4px; font-size: 0.85rem; font-weight: bold; pointer-events: none; transform: translate(-50%, -150%); box-shadow: 0 0 15px rgba(0, 210, 255, 0.6); z-index: 100; white-space: nowrap; }
        #tooltip::after { content: ''; position: absolute; top: 100%; left: 50%; margin-left: -6px; border-width: 6px; border-style: solid; border-color: rgba(0, 210, 255, 0.9) transparent transparent transparent; }

        .loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 1.2rem; color: #00d2ff; display: none; z-index: 999; }

        /* å…¨åŸŸé¡¯ç¤ºåˆ‡æ›æŒ‰éˆ• (å³ä¸Šè§’) */
        #ui-toggle-btn {
            position: absolute; top: 20px; right: 20px; width: 40px; height: 40px;
            background: rgba(10, 15, 25, 0.9); border: 1px solid #00d2ff; border-radius: 8px;
            color: #00d2ff; font-size: 1.2rem; cursor: pointer; z-index: 1000;
            display: flex; align-items: center; justify-content: center;
            backdrop-filter: blur(4px); transition: all 0.2s; box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
        }
        #ui-toggle-btn:hover { background: rgba(0, 210, 255, 0.2); box-shadow: 0 0 20px rgba(0, 210, 255, 0.4); transform: scale(1.05); }

    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <!-- Global Visibility Toggle -->
    <button id="ui-toggle-btn" onclick="toggleGlobalUI()" title="é¡¯ç¤º/éš±è—ä»‹é¢">ğŸ‘ï¸</button>

    <div id="info" class="ui-element">
        <h1>æ©Ÿè»Šå›æ”¶èƒ½æºæ¨¡çµ„</h1>
        <p>Motorcycle Energy Recovery Module</p>
        <p id="target-info">ç³»çµ±ç‹€æ…‹ï¼š<span class="highlight">æ­£å¸¸é‹ä½œä¸­</span></p>
        <p id="guide-text" style="font-size: 0.9rem; color: #ddd; margin-top: 5px;">é»æ“Šä¸‹æ–¹ã€Œå°è¦½ã€é–‹å§‹ä»‹ç´¹ï¼Œæˆ–ç›´æ¥æ“ä½œã€‚</p>
        <p style="font-size: 0.8rem; color: #00d2ff; margin-top: 8px; border-top: 1px solid #333; padding-top: 8px;">
            ğŸ’¡ æç¤ºï¼šé»æ“Šé›»æ± å¯é€²è¡Œæ‹”æ’æ›´æ›
        </p>
    </div>
    
    <div id="tour-overlay">æç¤ºè¨Šæ¯</div>
    <div id="interaction-hint"></div>
    <div id="tooltip">éƒ¨ä»¶åç¨±</div>

    <!-- Bottom Nav -->
    <div id="bottom-nav" class="ui-element">
        <button class="nav-btn" onclick="toggleDrawer()"><span>âš™ï¸</span>æ§åˆ¶</button>
        <button class="nav-btn" id="btn-tour" onclick="startTour()"><span>ğŸ“</span>å°è¦½</button>
        <button class="nav-btn" onclick="resetCamera()"><span>â†º</span>é‡ç½®</button>
    </div>

    <!-- Control Drawer -->
    <div id="control-drawer" class="ui-element">
        <div class="drawer-handle" onclick="toggleDrawer()"></div>
        
        <div class="control-group">
            <div class="control-label">é‹ä½œæ¨¡å¼</div>
            <div class="mode-switch">
                <button class="mode-btn active" id="btn-mode-store" onclick="setMode('store')">âš¡ å„²èƒ½</button>
                <button class="mode-btn" id="btn-mode-drive" onclick="setMode('drive')">ğŸš€ æ¨é€²</button>
            </div>
        </div>

        <div class="control-group">
            <div class="control-label">
                <span>è½‰é€Ÿ (RPM)</span>
                <span id="rpm-val" class="highlight">2000</span>
            </div>
            <input type="range" id="rpm-slider" min="800" max="5000" step="100" value="2000">
        </div>

        <div class="control-group">
            <div class="control-label">
                <span>æ•£ç†±æ•ˆç‡</span>
                <span id="cooling-val" class="highlight">50%</span>
            </div>
            <input type="range" id="cooling-slider" min="0" max="1" step="0.01" value="0.5">
        </div>

        <div class="control-group">
            <div class="control-label" style="justify-content: flex-start; gap: 10px;">
                <span>ğŸ”Š éŸ³æ•ˆ:</span>
                <button id="btn-sound" onclick="toggleSound()" style="background:transparent; border:1px solid #555; color:#aaa; border-radius:4px; padding:2px 8px;">é—œé–‰</button>
            </div>
        </div>
        
        <div style="text-align:center; margin-top:20px;">
            <button onclick="resetTanks()" style="background: #00d2ff; border:none; padding:10px 20px; border-radius:20px; color:#000; font-weight:bold;">â†º é‡ç½®é›»æ± ç‹€æ…‹</button>
        </div>
    </div>

    <div id="loading" class="loading">è¼‰å…¥ä¸­...</div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import TWEEN from 'https://cdn.jsdelivr.net/npm/@tweenjs/tween.js@18.6.4/dist/tween.esm.js'; 

        // --- Global Variables ---
        let scene, camera, renderer, controls;
        let moduleGroup;
        let particles, particleGeo, particleMaterial;
        let heatParticles, heatGeo, heatMaterial;
        let tanks = []; 
        let tankContainers = []; 
        let clock = new THREE.Clock();
        let raycaster, pointer;
        
        // Camera Targets (for Tour)
        const tourTargets = [
            { pos: {x:0, y:-2, z:12}, look: {x:0, y:-2, z:4}, text: "1. åº•ç›¤å¸å¡µå£\nå¸å…¥è·¯é¢ç²‰å¡µèˆ‡å»¢æ£„ç‰©" },
            { pos: {x:8, y:2, z:0}, look: {x:0, y:0, z:0}, text: "2. æ ¸å¿ƒåæ‡‰è‰™\nå°‡ç‰©è³ªçµç¢ä¸¦è½‰åŒ–ç‚ºèƒ½é‡" },
            { pos: {x:0, y:8, z:2}, look: {x:0, y:2, z:0}, text: "3. é›™æ¸¦è¼ªæ•£ç†±ç³»çµ±\nå‹•æ…‹ç†±æ°£æ’æ”¾ï¼Œç¢ºä¿é«˜æ•ˆé‹ä½œ" },
            { pos: {x:-6, y:0, z:-8}, look: {x:0, y:-1, z:-3.5}, text: "4. æ•´åˆæ¨é€²å–®å…ƒ\næœå¾Œä¸‹æ–¹å‚¾æ–œï¼Œæä¾›å°åœ°æ¨é€²åŠ›" },
            { pos: {x:0, y:-2, z:-10}, look: {x:0, y:-1, z:-5}, text: "5. æ¨¡çµ„åŒ–é›»æ± \né»æ“Šå¯é€²è¡Œç†±æ‹”æ’æ›´æ›" }
        ];
        let isTouring = false;

        const params = {
            rpm: 2000,             
            mode: 'store',         
            opacity: 0.7,          
            coolingLevel: 0.5,     
            energyColor: '#00ffff', 
            baseVibration: true,
            soundEnabled: false
        };

        const particleCount = 2000;
        const particleData = []; 
        const heatParticleCount = 1000;
        const heatData = [];
        const heatEmitters = []; 

        // --- Sound System ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const masterGain = audioCtx.createGain();
        masterGain.gain.value = 0.15;
        masterGain.connect(audioCtx.destination);
        let engineOsc = null;
        let engineGain = null;

        const SoundManager = {
            initEngine: () => {
                if (engineOsc) return;
                engineOsc = audioCtx.createOscillator();
                engineGain = audioCtx.createGain();
                engineOsc.type = 'sawtooth';
                engineOsc.frequency.value = 50; 
                engineGain.gain.value = 0; 
                const filter = audioCtx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 200;
                engineOsc.connect(filter);
                filter.connect(engineGain);
                engineGain.connect(masterGain);
                engineOsc.start();
            },
            updateEngine: (rpm) => {
                if (!params.soundEnabled || !engineOsc) return;
                const targetFreq = 40 + (rpm / 100); 
                const targetVol = 0.05 + (rpm / 10000); 
                engineOsc.frequency.setTargetAtTime(targetFreq, audioCtx.currentTime, 0.1);
                engineGain.gain.setTargetAtTime(targetVol, audioCtx.currentTime, 0.1);
            },
            playClick: () => {
                if (!params.soundEnabled) return;
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(600, audioCtx.currentTime);
                gain.gain.setValueAtTime(0.05, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.1);
                osc.connect(gain);
                gain.connect(masterGain);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.1);
            },
            playMechanical: (type) => { 
                if (!params.soundEnabled) return;
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'square';
                if (type === 'detach') {
                    osc.frequency.setValueAtTime(100, audioCtx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(40, audioCtx.currentTime + 0.3);
                    gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.3);
                } else {
                    osc.frequency.setValueAtTime(200, audioCtx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(800, audioCtx.currentTime + 0.2);
                    gain.gain.setValueAtTime(0.05, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.2);
                }
                osc.connect(gain);
                gain.connect(masterGain);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.3);
            },
            playHover: () => {
                 if (!params.soundEnabled) return;
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(800, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(1200, audioCtx.currentTime + 0.05);
                gain.gain.setValueAtTime(0.02, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.05);
                osc.connect(gain);
                gain.connect(masterGain);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.05);
            }
        };

        init();
        setupCustomControls(); 
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f2f5);
            scene.fog = new THREE.FogExp2(0xf0f2f5, 0.015);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(14, 9, 14);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            document.body.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 2;
            controls.maxDistance = 40;
            
            const ambientLight = new THREE.AmbientLight(0xffffff, 2.5);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
            dirLight.position.set(5, 10, 7);
            dirLight.castShadow = true;
            dirLight.shadow.bias = -0.0001;
            scene.add(dirLight);
            const backLight = new THREE.DirectionalLight(0x0044ff, 0.5);
            backLight.position.set(-5, 0, -5);
            scene.add(backLight);
            const coreLight = new THREE.PointLight(0x00d2ff, 5, 12);
            coreLight.position.set(0, 0, 0);
            scene.add(coreLight);
            params.coreLight = coreLight;

            buildModel();
            initParticles();
            initHeatParticles();

            raycaster = new THREE.Raycaster();
            pointer = new THREE.Vector2();
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('pointerdown', onClick);
            window.addEventListener('pointermove', onPointerMove);
        }

        // --- Mobile UI Logic ---
        window.toggleGlobalUI = function() {
            const uiIds = ['info', 'bottom-nav', 'control-drawer'];
            const btn = document.getElementById('ui-toggle-btn');
            const firstEl = document.getElementById(uiIds[0]);
            const isHidden = firstEl.classList.contains('ui-hidden');
            uiIds.forEach(id => {
                const el = document.getElementById(id);
                if (isHidden) el.classList.remove('ui-hidden'); else el.classList.add('ui-hidden');
            });
            btn.innerText = isHidden ? 'ğŸ‘ï¸' : 'âœ•';
            btn.style.borderColor = isHidden ? '#00d2ff' : '#ff3300';
            btn.style.color = isHidden ? '#00d2ff' : '#ff3300';
            SoundManager.playClick();
        };
        
        window.toggleDrawer = function() {
            const drawer = document.getElementById('control-drawer');
            drawer.classList.toggle('open');
            SoundManager.playClick();
        };

        function setupCustomControls() {
            const rpmSlider = document.getElementById('rpm-slider');
            const rpmVal = document.getElementById('rpm-val');
            rpmSlider.addEventListener('input', (e) => {
                params.rpm = parseInt(e.target.value);
                rpmVal.innerText = params.rpm;
                SoundManager.updateEngine(params.rpm); 
            });

            const coolSlider = document.getElementById('cooling-slider');
            const coolVal = document.getElementById('cooling-val');
            coolSlider.addEventListener('input', (e) => {
                params.coolingLevel = parseFloat(e.target.value);
                coolVal.innerText = Math.round(params.coolingLevel * 100) + '%';
            });
        }

        window.toggleSound = function() {
            params.soundEnabled = !params.soundEnabled;
            const btn = document.getElementById('btn-sound');
            if (params.soundEnabled) {
                if (audioCtx.state === 'suspended') audioCtx.resume();
                SoundManager.initEngine();
                SoundManager.updateEngine(params.rpm); 
                btn.innerText = "é–‹å•Ÿ";
                btn.style.color = "#00d2ff";
                btn.style.borderColor = "#00d2ff";
            } else {
                if (engineGain) engineGain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.1);
                btn.innerText = "é—œé–‰";
                btn.style.color = "#aaa";
                btn.style.borderColor = "#555";
            }
            SoundManager.playClick();
        };

        window.setMode = function(mode) {
            SoundManager.playClick();
            params.mode = mode;
            document.getElementById('btn-mode-store').classList.toggle('active', mode === 'store');
            document.getElementById('btn-mode-drive').classList.toggle('active', mode === 'drive');
            document.getElementById('btn-mode-drive').classList.toggle('drive', mode === 'drive'); 
            const colorHex = mode === 'store' ? 0x00d2ff : 0xffaa00;
            const colorStr = mode === 'store' ? '#00ffff' : '#ffaa00';
            if(params.glowMat) params.glowMat.color.setHex(colorHex);
            if(params.coreLight) params.coreLight.color.setHex(colorHex);
            params.energyColor = colorStr;
        };

        window.resetTanks = function() {
            SoundManager.playMechanical('detach');
            tanks.forEach(tank => tank.scale.y = 0.01);
        };

        window.startTour = function() {
            if(isTouring) return;
            isTouring = true;
            SoundManager.playClick();
            document.getElementById('control-drawer').classList.remove('open');
            
            let step = 0;
            const overlay = document.getElementById('tour-overlay');
            const guideText = document.getElementById('guide-text');
            const hint = document.getElementById('interaction-hint');
            
            function nextStep() {
                if(step >= tourTargets.length) {
                    isTouring = false;
                    overlay.style.display = 'none';
                    guideText.innerText = "å°è¦½çµæŸã€‚è«‹è‡ªç”±æ“ä½œã€‚";
                    hint.style.display = 'none';
                    window.resetCamera();
                    return;
                }
                
                const target = tourTargets[step];
                overlay.style.display = 'block';
                overlay.innerText = target.text;
                guideText.innerText = "å°è¦½é€²è¡Œä¸­...";
                
                new TWEEN.Tween(camera.position).to(target.pos, 1500).easing(TWEEN.Easing.Quadratic.Out).start();
                new TWEEN.Tween(controls.target).to(target.look, 1500).easing(TWEEN.Easing.Quadratic.Out).start();

                if(step === 4) hint.style.display = 'block'; else hint.style.display = 'none';

                step++;
                setTimeout(nextStep, 4500);
            }
            nextStep();
        };

        window.resetCamera = function() {
            SoundManager.playClick();
            new TWEEN.Tween(camera.position).to({x:14, y:9, z:14}, 1000).easing(TWEEN.Easing.Quadratic.Out).start();
            new TWEEN.Tween(controls.target).to({x:0, y:0, z:0}, 1000).easing(TWEEN.Easing.Quadratic.Out).start();
            document.getElementById('guide-text').innerText = "é»æ“Šä¸‹æ–¹ã€Œå°è¦½ã€é–‹å§‹ä»‹ç´¹ï¼Œæˆ–ç›´æ¥æ“ä½œã€‚";
        };

        // --- 3D Construction ---

        function buildModel() {
            moduleGroup = new THREE.Group();
            scene.add(moduleGroup);

            const darkMetalMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.6, metalness: 0.9 });
            const rustyMetalMat = new THREE.MeshStandardMaterial({ color: 0x2a2a2a, roughness: 0.8, metalness: 0.6 });
            const detailMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.4, metalness: 0.8 });
            const glassMat = new THREE.MeshPhysicalMaterial({ color: 0x88ccff, metalness: 0.1, roughness: 0.2, transmission: 0.2, thickness: 1.0, transparent: true, opacity: params.opacity });
            params.glassMat = glassMat;
            const glowMat = new THREE.MeshBasicMaterial({ color: 0x00d2ff });
            params.glowMat = glowMat;
            const redGlowMat = new THREE.MeshBasicMaterial({ color: 0xff3300 });

            // Intake
            const intakeGroup = new THREE.Group();
            intakeGroup.name = "å¸å¡µå£æ¨¡çµ„";
            intakeGroup.userData = { cameraOffset: {x: 4, y: 2, z: 8}, description: "åº•ç›¤ä¸‹æ–¹çš„å¼·åŠ›å¸å¡µè£ç½®ï¼Œè² è²¬å¸å…¥è·¯é¢ç²‰å¡µä¸¦é€²è¡Œçµç¢ã€‚" };
            intakeGroup.position.set(0, -2.2, 4); 
            intakeGroup.rotation.x = 0.2; 
            
            intakeGroup.add(new THREE.Mesh(new THREE.BoxGeometry(2.5, 1.5, 2.5), darkMetalMat));
            const mouthGeo = new THREE.CylinderGeometry(1.2, 1.2, 0.5, 32, 1, true); mouthGeo.rotateX(Math.PI/2); mouthGeo.translate(0,0,1.3);
            intakeGroup.add(new THREE.Mesh(mouthGeo, rustyMetalMat));
            const mouthGlow = new THREE.Mesh(new THREE.TorusGeometry(1.1, 0.05, 16, 32), redGlowMat); mouthGlow.position.z = 1.3;
            intakeGroup.add(mouthGlow);
            const bladeGeo = new THREE.BoxGeometry(2.0, 0.1, 0.4);
            const blade1 = new THREE.Mesh(bladeGeo, new THREE.MeshStandardMaterial({color:0x333333})); blade1.position.z = 0.8;
            const blade2 = blade1.clone(); blade2.rotation.z = Math.PI/2;
            params.blades = new THREE.Group(); params.blades.add(blade1, blade2);
            intakeGroup.add(params.blades);
            const mainPipe = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 0.6, 3.5, 16), rustyMetalMat); mainPipe.geometry.rotateX(Math.PI/2);
            mainPipe.position.set(0,0,-2);
            intakeGroup.add(mainPipe);
            moduleGroup.add(intakeGroup);

            // Chamber
            const chamberGroup = new THREE.Group();
            chamberGroup.name = "æ ¸å¿ƒåæ‡‰è‰™";
            chamberGroup.userData = { cameraOffset: {x: 5, y: 3, z: 0}, description: "é«˜å£“ç’°å¢ƒä¸‹å°‡å»¢æ£„ç‰©è½‰åŒ–ç‚ºå…‰èƒ½ç²’å­ã€‚" };
            const coreMesh = new THREE.Mesh(new THREE.IcosahedronGeometry(0.7, 2), glowMat);
            params.coreMesh = coreMesh;
            chamberGroup.add(coreMesh);
            const cageBarGeo = new THREE.BoxGeometry(0.2, 4, 0.2);
            for(let i=0; i<4; i++) {
                const bar = new THREE.Mesh(cageBarGeo, darkMetalMat); bar.rotation.x = Math.PI/2;
                const a = (i/4)*Math.PI*2; bar.position.set(Math.cos(a)*1.8, Math.sin(a)*1.8, 0); chamberGroup.add(bar);
            }
            const glassShell = new THREE.Mesh(new THREE.CylinderGeometry(1.6, 1.6, 3.8, 32, 1, true), glassMat); glassShell.geometry.rotateX(Math.PI/2);
            chamberGroup.add(glassShell);
            moduleGroup.add(chamberGroup);

            // Heatsink
            const heatsinkGroup = new THREE.Group();
            heatsinkGroup.name = "æ•£ç†±å†·å»ç³»çµ±";
            heatsinkGroup.userData = { cameraOffset: {x: 0, y: 6, z: 0}, description: "æ–°å‹é›™æ¸¦è¼ªæ•£ç†±è£ç½®ï¼Œå…·å‚™å‹•æ…‹ç†±æ°£æ’æ”¾åŠŸèƒ½ã€‚" };
            const mount = new THREE.Mesh(new THREE.BoxGeometry(2, 0.5, 2), darkMetalMat); mount.position.y = 2.0; heatsinkGroup.add(mount);
            const turbineGeo = new THREE.CylinderGeometry(0.8, 1.0, 2.5, 16); turbineGeo.rotateZ(Math.PI / 2); 
            const tLeft = new THREE.Mesh(turbineGeo, darkMetalMat); tLeft.position.set(-1.5, 2.5, 0); tLeft.rotation.z = 0.2; heatsinkGroup.add(tLeft);
            const tRight = new THREE.Mesh(turbineGeo, darkMetalMat); tRight.position.set(1.5, 2.5, 0); tRight.rotation.z = -0.2; heatsinkGroup.add(tRight);
            const ringGeo = new THREE.TorusGeometry(1.0, 0.05, 8, 16); const tRingMat = new THREE.MeshStandardMaterial({ color: 0xff3300, emissive: 0x330000 });
            [tLeft, tRight].forEach((t, idx) => {
                for(let j=0; j<3; j++) { const r = new THREE.Mesh(ringGeo, tRingMat); r.rotation.y = Math.PI/2; r.position.x = (j - 1) * 0.6; t.add(r); }
                const emitPos = new THREE.Vector3(); const sign = idx === 0 ? -1 : 1; emitPos.set(sign * 2.8, 2.8, 0); heatEmitters.push(emitPos); 
            });
            params.heatsink = heatsinkGroup;
            moduleGroup.add(heatsinkGroup);

            // --- Unified Propulsion Group (UPDATED: Back-Down Tilt) ---
            const propulsionGroup = new THREE.Group();
            propulsionGroup.name = "æ•´åˆå¼æ¨é€²ç³»çµ±";
            propulsionGroup.userData = { cameraOffset: {x: 5, y: 2, z: -6}, description: "çµåˆèƒ½æºåˆ†é…èˆ‡å„²å­˜çš„é«˜æ€§èƒ½æ¨é€²å–®å…ƒã€‚" };
            propulsionGroup.position.set(0, 0, -3.5);
            
            // Rotate 180 Y (face back) + Rotate 45 X (tilt down)
            propulsionGroup.rotation.set(Math.PI / 4, Math.PI, 0); 
            
            moduleGroup.add(propulsionGroup);

            // Interface
            propulsionGroup.add(new THREE.Mesh(new THREE.BoxGeometry(1.8, 1.2, 0.8), darkMetalMat));
            const pipeGeo = new THREE.CylinderGeometry(0.35, 0.35, 1.5, 24, 1, true); pipeGeo.rotateX(Math.PI / 2);
            const rimGeo = new THREE.TorusGeometry(0.35, 0.06, 8, 24);
            const pipePositions = [ { x: -0.5, y: 0.4 }, { x: 0.5, y: 0.4 }, { x: -0.5, y: -0.4 }, { x: 0.5, y: -0.4 } ];

            pipePositions.forEach((pos, i) => {
                const pipeContainer = new THREE.Group();
                pipeContainer.position.set(pos.x, pos.y, 0);
                const pipe = new THREE.Mesh(pipeGeo, rustyMetalMat); pipe.position.z = 0.5; 
                const rim = new THREE.Mesh(rimGeo, detailMat); rim.position.z = 1.25; 
                const innerGlow = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.1, 0.8, 16, 1, true), new THREE.MeshBasicMaterial({ 
                    color: 0x00aaff, transparent: true, opacity: 0.5, side: THREE.DoubleSide, blending: THREE.AdditiveBlending 
                }));
                innerGlow.geometry.rotateX(Math.PI/2); innerGlow.position.z = 0.8;
                pipeContainer.add(pipe, rim, innerGlow);
                propulsionGroup.add(pipeContainer);

                // Tank
                const tankContainer = new THREE.Group();
                tankContainer.name = `ç¨ç«‹é›»æ± å–®å…ƒ ${i+1}`; 
                tankContainer.userData = { isTank: true, id: i + 1, basePos: new THREE.Vector3(pos.x, pos.y, 0), isDetached: false };
                tankContainer.position.copy(tankContainer.userData.basePos);
                
                const tankGeo = new THREE.CylinderGeometry(0.35, 0.35, 2.2, 24); 
                tankGeo.rotateX(Math.PI / 2); 
                tankGeo.translate(0, 0, 2.4); 
                
                const tankMesh = new THREE.Mesh(tankGeo, new THREE.MeshPhysicalMaterial({ color: 0x222222, roughness: 0.4, metalness: 0.8 }));
                const cap = new THREE.Mesh(new THREE.CylinderGeometry(0.38, 0.38, 0.2, 24).rotateX(Math.PI/2), rustyMetalMat); cap.position.z = 3.5; tankMesh.add(cap);
                const ring1 = new THREE.Mesh(new THREE.TorusGeometry(0.36, 0.03, 8, 24), rustyMetalMat); ring1.position.z = 1.8; tankMesh.add(ring1);
                const ring2 = new THREE.Mesh(new THREE.TorusGeometry(0.36, 0.03, 8, 24), rustyMetalMat); ring2.position.z = 2.8; tankMesh.add(ring2);
                
                const barGeo = new THREE.CylinderGeometry(0.30, 0.30, 2.0, 16).rotateX(Math.PI/2).translate(0, 0, 2.3); 
                const energyBar = new THREE.Mesh(barGeo, glowMat.clone()); energyBar.scale.z = 0.01; 
                tankMesh.material = new THREE.MeshPhysicalMaterial({ color: 0x222222, roughness: 0.2, metalness: 0.8, transmission: 0.5, transparent: true, opacity: 0.6 });
                tankContainer.add(tankMesh, energyBar);
                
                propulsionGroup.add(tankContainer);
                tanks.push(energyBar);
                tankContainers.push(tankContainer);
            });

            // Frame
            const frame = new THREE.Mesh(new THREE.BoxGeometry(5, 0.5, 14), darkMetalMat);
            frame.position.set(0, -2.0, 2);
            moduleGroup.add(frame);
        }

        // Interaction Functions
        let lastHoveredObj = null;

        function onPointerMove(event) {
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(pointer, camera);
            const intersects = raycaster.intersectObjects(moduleGroup.children, true);
            const tooltip = document.getElementById('tooltip');
            
            if (intersects.length > 0) {
                let obj = intersects[0].object;
                while (obj.parent && obj.parent !== moduleGroup) { if (obj.name) break; obj = obj.parent; }
                if (obj && obj.name) {
                    if (lastHoveredObj !== obj) { SoundManager.playHover(); lastHoveredObj = obj; }
                    document.body.style.cursor = 'pointer';
                    tooltip.style.display = 'block';
                    tooltip.style.left = event.clientX + 'px';
                    tooltip.style.top = event.clientY + 'px';
                    tooltip.innerText = obj.name;
                    if (intersectedObject !== obj) {
                        if (intersectedObject) removeHighlight(intersectedObject);
                        intersectedObject = obj; addHighlight(intersectedObject);
                    }
                } else resetHover();
            } else resetHover();
        }
        function resetHover() {
            lastHoveredObj = null; 
            if (intersectedObject) { removeHighlight(intersectedObject); intersectedObject = null; }
            document.body.style.cursor = 'default';
            document.getElementById('tooltip').style.display = 'none';
        }
        function addHighlight(object) { object.traverse((child) => { if (child.isMesh && child.material.emissive) { if (!child.userData.originalEmissive) child.userData.originalEmissive = child.material.emissive.clone(); child.material.emissive = new THREE.Color(0x333333); } }); }
        function removeHighlight(object) { object.traverse((child) => { if (child.isMesh && child.userData.originalEmissive) child.material.emissive.copy(child.userData.originalEmissive); }); }

        function onClick(event) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            if (event.target.closest('#control-drawer') || event.target.closest('#bottom-nav') || event.target.closest('#top-bar')) return;

            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(pointer, camera);
            const intersects = raycaster.intersectObjects(moduleGroup.children, true);

            if (intersects.length > 0) {
                let obj = intersects[0].object;
                while (obj.parent && obj.parent !== moduleGroup) { if (obj.userData.isTank) break; obj = obj.parent; }

                if (obj && obj.userData.isTank) {
                    SoundManager.playClick();
                    const tank = obj;
                    tank.userData.isDetached = !tank.userData.isDetached;
                    if(tank.userData.isDetached) SoundManager.playMechanical('detach');
                    else SoundManager.playMechanical('attach');
                }
            }
        }

        function initParticles() {
            particleGeo = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);
            for (let i = 0; i < particleCount; i++) { resetParticle(i); positions[i*3] = 1000; sizes[i] = 0.0; }
            particleGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particleGeo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            particleGeo.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            const cvs = document.createElement('canvas'); cvs.width=32; cvs.height=32;
            const ctx = cvs.getContext('2d'); ctx.beginPath(); ctx.arc(16,16,14,0,Math.PI*2); ctx.fillStyle='white'; ctx.fill();
            const pointTex = new THREE.CanvasTexture(cvs);
            particleMaterial = new THREE.ShaderMaterial({
                uniforms: { pointTexture: { value: pointTex }, globalOpacity: { value: 0.8 } },
                vertexShader: `attribute float size; attribute vec3 color; varying vec3 vColor; void main() { vColor = color; vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 ); gl_PointSize = size * ( 300.0 / -mvPosition.z ); gl_Position = projectionMatrix * mvPosition; }`,
                fragmentShader: `uniform sampler2D pointTexture; uniform float globalOpacity; varying vec3 vColor; void main() { gl_FragColor = vec4( vColor, globalOpacity ); gl_FragColor = gl_FragColor * texture2D( pointTexture, gl_PointCoord ); if (gl_FragColor.a < 0.1) discard; }`,
                transparent: true, depthWrite: false, blending: THREE.NormalBlending
            });
            particles = new THREE.Points(particleGeo, particleMaterial);
            scene.add(particles);
        }

        function resetParticle(i) {
            if (!particleData[i]) particleData[i] = {};
            const d = particleData[i]; d.state = 0;
            const angle = Math.random() * Math.PI * 2; const r = 2 + Math.random() * 2;
            d.x = Math.cos(angle) * r; d.y = -4 + Math.random() * 1.5; d.z = 6 + Math.random() * 3; 
            d.life = 1.0; d.r = 0.6 + Math.random() * 0.2; d.g = 0.5 + Math.random() * 0.2; d.b = 0.4 + Math.random() * 0.2; d.size = 1.5 + Math.random() * 1.0; 
        }
        
        function resetParticleToTank(i, container) {
            if (!particleData[i]) particleData[i] = {};
            const d = particleData[i]; d.state = 6;
            const worldPos = new THREE.Vector3(); container.getWorldPosition(worldPos);
            d.x = worldPos.x + (Math.random() - 0.5) * 0.3;
            d.y = worldPos.y + (Math.random() - 0.5) * 0.3;
            d.z = worldPos.z + (Math.random() - 0.5) * 0.3;
            d.life = 1.0; d.r = 1.0; d.g = 0.6; d.b = 0.0; d.size = 0.6;
            
            // Eject DOWN-BACK (0, -1, -1) in world space
            d.vx = (Math.random()-0.5)*0.2; 
            d.vy = -(0.8 + Math.random()*0.5); 
            d.vz = -(0.8 + Math.random()*0.5);
        }

        function initHeatParticles() {
            heatGeo = new THREE.BufferGeometry();
            const positions = new Float32Array(heatParticleCount * 3);
            const colors = new Float32Array(heatParticleCount * 3);
            for(let i=0; i<heatParticleCount; i++) { heatData[i] = { x:0, y:0, z:0, vx: 0, vy: 0, life: Math.random(), speed: 0.05 + Math.random() * 0.05 }; positions[i*3] = 1000; }
            heatGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            heatGeo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            heatMaterial = new THREE.PointsMaterial({ size: 0.4, vertexColors: true, transparent: true, opacity: 0.6, depthWrite: false, blending: THREE.AdditiveBlending });
            heatParticles = new THREE.Points(heatGeo, heatMaterial);
            moduleGroup.add(heatParticles);
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();
            
            TWEEN.update();
            controls.update();
            SoundManager.updateEngine(params.rpm);

            tankContainers.forEach((tankContainer, i) => {
                let targetPos = tankContainer.userData.basePos.clone();
                if (tankContainer.userData.isDetached) {
                    // Eject: Local Z+ which is Down-Back (because group is tilted X 45, Y 180)
                    targetPos.z += 1.5; 
                }
                tankContainer.position.lerp(targetPos, 0.1);

                if (!tankContainer.userData.isDetached) {
                    const tankEnergyBar = tanks[i];
                    const speed = params.rpm / 2000;
                    if (params.mode === 'drive') {
                        if (tankEnergyBar.scale.z > 0.01) { tankEnergyBar.scale.z -= 0.001 * speed; tankEnergyBar.material.color.setHex(0xffaa00); }
                        else { tankEnergyBar.scale.z = 0.01; }
                    } else { tankEnergyBar.material.color.setHex(0x00ffff); }
                }
            });

            if (params.blades) params.blades.rotation.z -= (params.rpm / 60000) * Math.PI * 2;
            if (params.coreMesh) { const pulse = 1 + Math.sin(time * 5) * 0.1 * (params.rpm/2000); params.coreMesh.scale.set(pulse, pulse, pulse); }
            if (params.baseVibration) { const vib = (params.rpm / 5000) * 0.01; moduleGroup.position.set((Math.random()-0.5)*vib, (Math.random()-0.5)*vib, 0); }

            if (particles.visible) {
                const pos = particleGeo.attributes.position.array;
                const col = particleGeo.attributes.color.array;
                const sizes = particleGeo.attributes.size.array;
                const speed = params.rpm / 2000;
                const targetC = new THREE.Color(params.energyColor);
                for (let i = 0; i < particleCount; i++) {
                    const d = particleData[i];
                    if (d.state === 0) {
                        const tx = 0; const ty = -2.2; const tz = 4.5;
                        d.x += (tx - d.x) * 1.5 * delta * speed; d.y += (ty - d.y) * 1.5 * delta * speed; d.z += (tz - d.z) * 1.5 * delta * speed;
                        d.x += Math.sin(time * 5 + i) * 0.02;
                        if (Math.abs(tz - d.z) < 0.8 && Math.abs(ty - d.y) < 0.8) d.state = 1;
                    } else if (d.state === 1) {
                        d.z -= 5 * delta * speed; d.x += (Math.random() - 0.5) * 0.5; d.y += (Math.random() - 0.5) * 0.5; d.size *= 0.85; d.r = targetC.r; d.g = targetC.g; d.b = targetC.b;
                        if (d.z < 2) { d.state = 2; d.size = 0.2; }
                    } else if (d.state === 2) {
                        const ang = time * 5 * speed + i; d.x = Math.cos(ang) * 1.2 * Math.random(); d.y = Math.sin(ang) * 1.2 * Math.random(); d.z -= 1.5 * delta * speed; if (d.z < -2) d.state = 3;
                    } else if (d.state === 3) {
                        // Flow DOWN to Interface (-3.5, -1.0)
                        d.z -= 1.0 * delta * speed; 
                        if(d.y > -1.0) d.y -= 1.2 * delta * speed; 

                        if (d.z < -3.0) {
                            if (params.mode === 'store') {
                                d.state = 4; const tIdx = Math.floor(Math.random() * 4);
                                if (!tankContainers[tIdx].userData.isDetached) { if (tanks[tIdx].scale.z < 1) tanks[tIdx].scale.z += 0.005 * speed; }
                            } else { d.state = 5; }
                        }
                    } else if (d.state === 4) { d.life -= delta * 2; }
                    else if (d.state === 5) { 
                        // Drive/Bypass: Shoot DOWN-BACK (Groundward)
                        d.z -= 8 * delta * speed; d.y -= 8 * delta * speed; d.life -= delta; 
                    }
                    else if (d.state === 6) { 
                        // Tank Discharge: Shoot DOWN-BACK
                        d.x += d.vx * delta * speed * 20; d.y += d.vy * delta * speed * 20; d.z += d.vz * delta * speed * 20; d.life -= delta; 
                    }

                    if (d.life <= 0 || d.z < -10 || d.y < -10) {
                        if (params.mode === 'drive' && Math.random() < 0.05) {
                            const tIdx = Math.floor(Math.random() * 4);
                            if (!tankContainers[tIdx].userData.isDetached && tanks[tIdx].scale.z > 0.1) resetParticleToTank(i, tankContainers[tIdx]); else resetParticle(i);
                        } else resetParticle(i);
                    }
                    pos[i*3] = d.x; pos[i*3+1] = d.y; pos[i*3+2] = d.z; col[i*3] = d.r; col[i*3+1] = d.g; col[i*3+2] = d.b; sizes[i] = d.size;
                }
                particleGeo.attributes.position.needsUpdate = true; particleGeo.attributes.color.needsUpdate = true; particleGeo.attributes.size.needsUpdate = true;
            }

            const hPos = heatGeo.attributes.position.array; const hCol = heatGeo.attributes.color.array;
            const heatIntensity = (params.rpm / 5000) * (1.5 - params.coolingLevel);
            for(let i=0; i<heatParticleCount; i++) {
                let h = heatData[i]; h.life -= delta * (0.5 + heatIntensity);
                if (h.life <= 0) {
                    if (heatEmitters.length > 0 && Math.random() < heatIntensity) {
                        const emitIdx = Math.floor(Math.random() * heatEmitters.length); const emitPos = heatEmitters[emitIdx];
                        h.x = emitPos.x + (Math.random()-0.5)*0.5; h.y = emitPos.y + (Math.random()-0.5)*0.5; h.z = emitPos.z + (Math.random()-0.5)*0.5; h.life = 1.0;
                        h.vx = (emitPos.x > 0 ? 1 : -1) * (0.5 + Math.random()) * heatIntensity; h.vy = (0.5 + Math.random()) * heatIntensity;
                    } else h.x = 1000; 
                } else { h.x += h.vx * delta * 5; h.y += h.vy * delta * 5; hCol[i*3] = 1.0; hCol[i*3+1] = 0.2 + (1-h.life)*0.5; hCol[i*3+2] = 0.0; }
                hPos[i*3] = h.x; hPos[i*3+1] = h.y; hPos[i*3+2] = h.z;
            }
            heatGeo.attributes.position.needsUpdate = true; heatGeo.attributes.color.needsUpdate = true;
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>
